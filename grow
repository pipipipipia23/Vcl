getgenv().code = {
    "CONCAC"
}

repeat wait() until game:IsLoaded()
wait(10)

-- Services
local Services = setmetatable({}, {
    __index = function(_, Name)
        return cloneref(game:GetService(Name))
    end
})

local coreGui = Services.CoreGui
local workspace = Services.Workspace
local playerService = Services.Players
local replicatedStorage = Services.ReplicatedStorage
local runService = Services.RunService
local virtualUser = Services.VirtualUser
local Player = game.Players.LocalPlayer
-- Player references
local plr = playerService.LocalPlayer

-- Config
local CONFIG = {
    CLIENT_FPS = 3,
    MAX_SLOTS = 200,
    AVAILABLE_CROPS = 800,
    BATCH_SIZE = 10, -- Added batch size to CONFIG
    MAX_TREES = 100, -- Reduced to 50 trees
    LOCATIONS = {
        NIGHT_SHOP = CFrame.new(-100.395744, 4.47998381, -13.8326654, 0.995652378, -8.18297465e-08, 0.0931467712, 8.79529196e-08, 1, -6.16316811e-08, -0.0931467712, 6.95562647e-08, 0.995652378)
    },
    -- Money thresholds for farming decisions
    MONEY_THRESHOLDS = {
        -- Tree removal thresholds
        TREE_REMOVAL = {
            START_REMOVING = 120000,        -- Don't remove any trees below this amount
            COMMON = 120000,                -- Remove common trees at this threshold
            UNCOMMON = 250000,              -- Remove uncommon trees at this threshold
            RARE = 1000000,                 -- Remove rare trees at this threshold
            EPIC = 10000000,                -- Remove epic trees at this threshold
            -- Mythic and Divine are never automatically removed
        },
        -- Seed buying thresholds (stop buying at this amount)
        SEED_BUYING = {
            STOP_COMMON = 500000,           -- Stop buying common seeds above this amount
            STOP_UNCOMMON = 1000000,        -- Stop buying uncommon seeds above this amount
            STOP_RARE = 5000000,            -- Stop buying rare seeds above this amount
            STOP_EPIC = 25000000,           -- Stop buying epic seeds above this amount
            -- Always buy legendary, mythic, divine seeds
        },
        -- Egg buying thresholds
        EGG_BUYING = {
            STOP_COMMON = 500000,           -- Stop buying common eggs above this amount
            STOP_UNCOMMON = 1000000,        -- Stop buying uncommon eggs above this amount
            STOP_RARE = 5000000,            -- Stop buying rare eggs above this amount
            STOP_EPIC = 25000000,           -- Stop buying epic eggs above this amount
            -- Always buy legendary, mythic, divine eggs
        }
    },
    SELL_FILTERS = getgenv().config or {
        ['Common'] = true,
        ['Uncommon'] = true,
        ['Rare'] = true,
        ['Legendary'] = true,
        ['Mythical'] = true,
        ['Divine'] = true
    },
    RARITY_ORDER = {
        ['Divine'] = 6,
        ['Mythical'] = 5,
        ['Legendary'] = 4,
        ['Epic'] = 3,
        ['Rare'] = 2,
        ['Uncommon'] = 1.5,
        ['Common'] = 1,
        ["Prismatic"] = 10,
    },
    PLANT_FILTER = {
        ['Common'] = true,
        ['Uncommon'] = true,
        ['Rare'] = true,
        ['Legendary'] = true,
        ['Mythical'] = true,
        ['Divine'] = true,
        ["Prismatic"] = true,
    },
    UI = {
        BACKGROUND_COLOR = Color3.fromRGB(25, 25, 35),         -- Darker background
        PANEL_COLOR = Color3.fromRGB(35, 35, 45),              -- Darker panel
        HEADER_COLOR = Color3.fromRGB(30, 30, 50),             -- Header with dark blue tint
        TEXT_COLOR = Color3.fromRGB(235, 235, 245),            -- Brighter text
        ACCENT_COLOR = Color3.fromRGB(85, 215, 130),           -- Vibrant green
        ERROR_COLOR = Color3.fromRGB(245, 80, 80),             -- Bright red
        WARNING_COLOR = Color3.fromRGB(250, 190, 60),          -- Orange-yellow
        INFO_COLOR = Color3.fromRGB(70, 170, 255),             -- Bright blue
        SECONDARY_COLOR = Color3.fromRGB(130, 120, 240),       -- Purple accent
        GRADIENT_START = Color3.fromRGB(35, 35, 55),           -- Gradient start
        GRADIENT_END = Color3.fromRGB(25, 25, 35)              -- Gradient end
    }
}

-- Tree state persistence system
function getStateFilePath()
    -- Create a safe filename by removing any invalid characters from the player name
    local safePlayerName = plr.Name:gsub("[^%w_]", "_")
    return "GrowGarden_TreeState_" .. safePlayerName .. ".txt"
end

-- Function to save state to a file
function saveTreeState(treeCount)
    if not writefile then
        log("Error", "Your executor does not support file operations - state cannot be saved", true)
        return false
    end
    
    local STATE_FILE_PATH = getStateFilePath()
    local stateData = {
        timestamp = os.time(),
        treeCount = treeCount,
        maxTrees = CONFIG.MAX_TREES,
        needsRemoval = treeCount > CONFIG.MAX_TREES,
        playerName = plr.Name
    }
    
    local success, result = pcall(function()
        local jsonData = game:GetService("HttpService"):JSONEncode(stateData)
        writefile(STATE_FILE_PATH, jsonData)
        return true
    end)
    
    if success and result then
        log("System", "Saved tree state to file for " .. plr.Name .. ": " .. treeCount .. " trees")
        return true
    else
        log("Error", "Failed to save tree state: " .. tostring(result), true)
        return false
    end
end

-- Function to load state from a file
function loadTreeState()
    if not readfile or not isfile then
        log("Warning", "Your executor does not support file operations - state cannot be loaded")
        return nil
    end
    
    local STATE_FILE_PATH = getStateFilePath()
    if not isfile(STATE_FILE_PATH) then
        log("System", "No saved tree state found for " .. plr.Name)
        return nil
    end
    
    local success, stateData = pcall(function()
        local fileContent = readfile(STATE_FILE_PATH)
        local data = game:GetService("HttpService"):JSONDecode(fileContent)
        return data
    end)
    
    if success and stateData then
        -- Validate the data to make sure it's not too old (e.g., no older than 12 hours)
        local currentTime = os.time()
        local maxAge = 12 * 60 * 60 -- 12 hours in seconds
        
        if currentTime - stateData.timestamp > maxAge then
            log("Warning", "Saved tree state is too old (>12 hours), ignoring")
            pcall(function() delfile(STATE_FILE_PATH) end)
            return nil
        end
        
        -- Check if the state is for the current player
        if stateData.playerName ~= plr.Name then
            log("Warning", "Saved tree state doesn't match current player, ignoring")
            return nil
        end
        
        log("System", "Loaded tree state for " .. plr.Name .. ": " .. stateData.treeCount .. " trees")
        return stateData
    else
        log("Error", "Failed to load tree state: " .. tostring(stateData), true)
        return nil
    end
end

-- Security check 
function secureScript()
    warn('[Security]: Performing script security check ...')
    for i = 0, 1 do
        local this = getfenv(i).script
        if not this or this ~= script then
            plr:Kick('Executor Issue')
            task.wait(1)
            while true do debug.traceback() end
        end
        this.Name = ''
        this.Parent = nil
    end
    warn('[Security]: Script security check passed')

    local antiCheat = plr.PlayerScripts:WaitForChild('LocalScript2', 30)
    if antiCheat then antiCheat.Disabled = true end
end
secureScript()

-- Game references
local modules = replicatedStorage:WaitForChild('Modules', 30)
local dataFolder = replicatedStorage:WaitForChild('Data', 30)
local gameEvents = replicatedStorage:WaitForChild('GameEvents', 30)

-- Required modules
local dataService = require(modules:WaitForChild('DataService', 30))
local seedData = require(dataFolder:WaitForChild('SeedData', 30))
local gearData = require(dataFolder:WaitForChild('GearData', 30))
local petEggData = require(dataFolder:WaitForChild('PetEggData', 30))
local PetRegistry = require(dataFolder:WaitForChild('PetRegistry', 30))
local ListPetData = require(dataFolder.PetRegistry.PetList)

-- Game events
local buySeedStock = gameEvents:WaitForChild('BuySeedStock', 30)
local buyGearStock = gameEvents:WaitForChild('BuyGearStock', 30)
local sellItem = gameEvents:WaitForChild('Sell_Item', 30)
local sellInventory = gameEvents:WaitForChild('Sell_Inventory', 30)
local plantRE = gameEvents:WaitForChild('Plant_RE', 30)
local waterRE = gameEvents:WaitForChild('Water_RE', 30)
local sprinklerService = gameEvents:WaitForChild('SprinklerService', 30)
local seedPackGiverEvent = gameEvents:WaitForChild('SeedPackGiverEvent', 30)
local petsService = gameEvents:WaitForChild('PetsService', 30)
local buyPetEgg = gameEvents:WaitForChild('BuyPetEgg', 30)
local petEggService = gameEvents:WaitForChild('PetEggService', 30)
local giftPet = gameEvents:WaitForChild('GiftPet', 30)
local petGiftingService = gameEvents:WaitForChild('PetGiftingService', 30)
local acceptPetGift = gameEvents:WaitForChild('AcceptPetGift', 30)
local nightQuestRemoteEvent = gameEvents:WaitForChild('NightQuestRemoteEvent', 30)
local removeItem = gameEvents:WaitForChild('Remove_Item', 30)
local stockdata = require(game:GetService("ReplicatedStorage").Data.EventShopData)
local remoteModule = require(replicatedStorage.Modules.Remotes)

-- Blacklisted seeds
local blacklistSeeds = {
    Corn = true
}

-- Utility functions
local Utility = {
    cache = {
        connections = {}
    }
}

function Utility.getCharacter()
    local character = Utility.cache.character

    if character and character:IsDescendantOf(workspace) and character:FindFirstChild('HumanoidRootPart') and character:FindFirstChild('Humanoid') and character.Humanoid.Health > 0 then
        return character
    end

    while true do
        if plr.Character and
            plr.Character:IsDescendantOf(workspace) and
            plr.Character:FindFirstChild('HumanoidRootPart') and
            plr.Character:FindFirstChild('Humanoid') and
            plr.Character.Humanoid.Health > 0 then
            Utility.cache.character = plr.Character
            return plr.Character
        end
        task.wait(0)
    end
end

function Utility.safeTaskWait(time)
    time = time or 0
    return task.wait(time * (CONFIG.CLIENT_FPS / 60))
end

function Utility.freezeCharacter()
    local character = Utility.getCharacter()
    local humanoid = character:FindFirstChild('Humanoid')
    local humanoidRootPart = character:FindFirstChild('HumanoidRootPart')

    if humanoid then
        humanoid.Sit = false
    end
    
    if humanoidRootPart and humanoidRootPart:FindFirstChild('jacky') then
        return humanoidRootPart:FindFirstChild('jacky')
    end

    if humanoidRootPart then
        humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        local bv = Instance.new('BodyVelocity')
        bv.Name = 'jacky'
        bv.Parent = humanoidRootPart
        bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        bv.Velocity = Vector3.new(0, 0, 0)

        if setfflag then
            pcall(setfflag, 'HumanoidParallelRemoveNoPhysics', 'False')
            pcall(setfflag, 'HumanoidParallelRemoveNoPhysicsNoSimulate2', 'False')
        end
        return bv
    end
    return nil
end

function Utility.disableCollide()
    local character = Utility.getCharacter()
    if Utility.cache['collideRunning'] then return end

    Utility.cache['collide'] = true
    Utility.cache['collideRunning'] = true

    local connection = runService.Stepped:Connect(function()
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA('BasePart') then
                part.CanCollide = false
                part.Massless = true
            end
        end
    end)

    Utility.cache.connections[#Utility.cache.connections+1] = connection
end

function Utility.enableCanCollide()
    local character = Utility.getCharacter()
    Utility.cache['collide'] = false

    task.wait(0.1)

    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA('BasePart') then
            part.CanCollide = true
            part.Massless = false
        end
    end
end

function Utility.isRipeFruit(fruit)
    local maxAge = fruit:GetAttribute('MaxAge')
    local grow = fruit:FindFirstChild('Grow')
    local ageObj = grow and grow:FindFirstChild('Age')

    if not maxAge or not ageObj then return false end
    return ageObj.Value >= maxAge
end

function Utility.tryCollect(currentSlot, prompt)
    local plant = prompt.Parent
    if plant == nil then return false end

    local location = plant:IsA('Model') and plant:GetModelCFrame() or plant.CFrame
    if currentSlot + 1 > CONFIG.MAX_SLOTS then return 'MAX' end

    local success = pcall(function()
        local character = Utility.getCharacter()
        local distance = (character.HumanoidRootPart.Position - location.Position).Magnitude
        if distance > 10 then
            character.HumanoidRootPart.CFrame = location
            task.wait(0.1)
        end
        fireproximityprompt(prompt)
    end)

    return success
end

function Utility.canPlace(farm, eggPart, radius)
    local eggPartSize = eggPart.Size
    local eggPartCFrame = eggPart.CFrame
    local delta = 1

    local angles = {
        Vector3.new(-eggPartSize.X / 2 + delta, 0, -eggPartSize.Z / 2 + delta),
        Vector3.new(-eggPartSize.X / 2 + delta, 0, eggPartSize.Z / 2 - delta),
        Vector3.new(eggPartSize.X / 2 - delta, 0, -eggPartSize.Z / 2 + delta),
        Vector3.new(eggPartSize.X / 2 - delta, 0, eggPartSize.Z / 2 - delta),
    }

    for _, offset in next, angles do
        local worldPosition = eggPartCFrame * offset
        if not Utility.isEggPlacedAt(farm, worldPosition, radius) then
            return worldPosition
        end
    end
    return nil
end

function Utility.isEggPlacedAt(farm, placePosition, radius)
    radius = radius or 5

    local objectsPhysical = farm.Important.Objects_Physical
    
    -- Check ALL eggs in the objects folder, not just the first one
    for _, object in pairs(objectsPhysical:GetChildren()) do
        if object.Name == 'PetEgg' then
            local primaryPart = object.PrimaryPart
            if primaryPart then
                local distance = (primaryPart.Position - placePosition).Magnitude
                if distance <= radius then
                    return true -- Position is too close to an existing egg
                end
            end
        end
    end
    
    return false -- No eggs found at this position
end

-- Stats tracking
local STATS = {
    startTime = tick(),
    moneyAtStart = 0,
    currentMoney = 0,
    moneyGained = 0,
    moneyPerMinute = 0,
    plantsCollected = 0,
    seedsPlanted = 0,
    petsHatched = 0,
    treesRemoved = 0,
    logs = {}
}

-- Add a flag to track tree removal status
local IS_REMOVING_TREES = false

-- User module functions
local Farm = nil
local NPCs = nil
local UI = {
    mainFrame = nil,
    statusLabel = nil,
    statusIndicator = nil,
    moneyLabel = nil,
    rateLabel = nil,
    statsLabels = {},
    logContainer = nil
}

-- Logger function
function log(category, message, isError)
    local timestamp = os.date("%H:%M:%S")
    local entry = {
        time = timestamp,
        category = category,
        message = message,
        isError = isError or false,
        timestamp = tick()
    }
    
    -- Add to beginning of logs array
    table.insert(STATS.logs, 1, entry)
    
    -- Keep log size manageable
    if #STATS.logs > 100 then
        table.remove(STATS.logs, 100)
    end
    
    -- Print to console with formatting
    if isError then
        warn(string.format("[%s] [%s] %s", timestamp, category, message))
    else
        print(string.format("[%s] [%s] %s", timestamp, category, message))
    end
    
    addLogToUI(entry)
    
    if UI.statusLabel then
        UI.statusLabel.Text = message
        
        -- Update status indicator color
        if UI.statusIndicator then
            if isError then
                UI.statusIndicator.BackgroundColor3 = CONFIG.UI.ERROR_COLOR
            elseif category == "Warning" then
                UI.statusIndicator.BackgroundColor3 = CONFIG.UI.WARNING_COLOR
            else
                UI.statusIndicator.BackgroundColor3 = CONFIG.UI.ACCENT_COLOR
            end
        end
    end
end

function waitDataLoadedAndGetFarm()
    warn('[Data]: Loading ...')
     
    local dataFullyLoaded = nil
    repeat
        Utility.safeTaskWait(1)
        dataFullyLoaded = plr:GetAttribute('DataFullyLoaded')
    until dataFullyLoaded

    while Farm == nil do
        for _, farm in next, workspace.Farm:GetChildren() do
            if farm:FindFirstChild('Important') and farm.Important:FindFirstChild('Data') and farm:GetAttribute('Loaded') == true then
                local data = farm.Important.Data
                if string.find(data.Owner.Value, plr.Name) then
                    warn('[Data]: Slot number:', data.Farm_Number.Value)
                    warn('[Data]: Owner:', data.Owner.Value)
                    Farm = farm
                    break
                end
            end
        end
        Utility.safeTaskWait(1)
    end
    
    NPCs = workspace.NPCS
end

function setupCharacter()
    warn('[Character]: Setting up ...')
    Utility.freezeCharacter()
    Utility.disableCollide()
end

function createStatus()
    if UI.mainFrame and UI.mainFrame.Parent then
        UI.mainFrame.Parent:Destroy()
    end

    -- Create main ScreenGui container
    local screenGui = Instance.new('ScreenGui')
    screenGui.Name = 'GrowGardenProUI'
    screenGui.ResetOnSpawn = false
    
    -- Try to parent to CoreGui for better persistence
    pcall(function()
        screenGui.Parent = coreGui
    end)
    
    if not screenGui.Parent then
        screenGui.Parent = plr:WaitForChild("PlayerGui")
    end

    -- Main frame
    local mainFrame = Instance.new('Frame')
    mainFrame.Name = 'MainFrame'
    mainFrame.Size = UDim2.new(0, 400, 0, 480)
    mainFrame.Position = UDim2.new(1, -420, 0.5, -240)
    mainFrame.BackgroundColor3 = CONFIG.UI.BACKGROUND_COLOR
    mainFrame.BorderSizePixel = 0
    mainFrame.ClipsDescendants = true
    mainFrame.Parent = screenGui
    
    -- Add background gradient
    local backgroundGradient = Instance.new('Frame')
    backgroundGradient.Name = 'BackgroundGradient'
    backgroundGradient.Size = UDim2.new(1, 0, 1, 0)
    backgroundGradient.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    backgroundGradient.BorderSizePixel = 0
    backgroundGradient.ZIndex = 0
    backgroundGradient.Parent = mainFrame
    
    local gradient = Instance.new('UIGradient')
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, CONFIG.UI.GRADIENT_START),
        ColorSequenceKeypoint.new(1, CONFIG.UI.GRADIENT_END)
    })
    gradient.Rotation = 45
    gradient.Parent = backgroundGradient
    
    -- Add outer glow
    local outerGlow = Instance.new('ImageLabel')
    outerGlow.Name = 'OuterGlow'
    outerGlow.AnchorPoint = Vector2.new(0.5, 0.5)
    outerGlow.BackgroundTransparency = 1
    outerGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
    outerGlow.Size = UDim2.new(1, 50, 1, 50)
    outerGlow.ZIndex = -1
    outerGlow.Image = "rbxassetid://6014261993"
    outerGlow.ImageColor3 = CONFIG.UI.ACCENT_COLOR
    outerGlow.ImageTransparency = 0.85
    outerGlow.Parent = mainFrame
    
    -- Rounded corners
    local cornerRadius = Instance.new('UICorner')
    cornerRadius.CornerRadius = UDim.new(0, 10)
    cornerRadius.Parent = mainFrame
    
    -- Title bar
    local titleBar = Instance.new('Frame')
    titleBar.Name = 'TitleBar'
    titleBar.Size = UDim2.new(1, 0, 0, 45)
    titleBar.BackgroundColor3 = CONFIG.UI.HEADER_COLOR
    titleBar.BorderSizePixel = 0
    titleBar.ZIndex = 2
    titleBar.Parent = mainFrame
    
    local titleCorner = Instance.new('UICorner')
    titleCorner.CornerRadius = UDim.new(0, 10)
    titleCorner.Parent = titleBar
    
    -- Fix corner overlap
    local fixTitleCorner = Instance.new('Frame')
    fixTitleCorner.Name = 'FixCorner'
    fixTitleCorner.Size = UDim2.new(1, 0, 0.6, 0)
    fixTitleCorner.Position = UDim2.new(0, 0, 0.5, 0)
    fixTitleCorner.BackgroundColor3 = CONFIG.UI.HEADER_COLOR
    fixTitleCorner.BorderSizePixel = 0
    fixTitleCorner.ZIndex = 2
    fixTitleCorner.Parent = titleBar
    
    -- Logo icon
    local logoIcon = Instance.new('ImageLabel')
    logoIcon.Name = 'LogoIcon'
    logoIcon.Size = UDim2.new(0, 28, 0, 28)
    logoIcon.Position = UDim2.new(0, 15, 0, 8)
    logoIcon.BackgroundTransparency = 1
    logoIcon.Image = "rbxassetid://7734010488"  -- Tree icon
    logoIcon.ImageColor3 = CONFIG.UI.ACCENT_COLOR
    logoIcon.ZIndex = 3
    logoIcon.Parent = titleBar
    
    -- Title text
    local titleText = Instance.new('TextLabel')
    titleText.Name = 'TitleText'
    titleText.Size = UDim2.new(1, -130, 1, 0)
    titleText.Position = UDim2.new(0, 52, 0, 0)
    titleText.BackgroundTransparency = 1
    titleText.Font = Enum.Font.GothamBold
    titleText.TextSize = 18
    titleText.TextColor3 = CONFIG.UI.TEXT_COLOR
    titleText.TextXAlignment = Enum.TextXAlignment.Left
    titleText.Text = "GrowGarden Pro Farm"
    titleText.ZIndex = 3
    titleText.Parent = titleBar
    
    -- Version label
    local versionText = Instance.new('TextLabel')
    versionText.Name = 'VersionText'
    versionText.Size = UDim2.new(0, 70, 0, 18)
    versionText.Position = UDim2.new(0, 53, 1, -18)
    versionText.BackgroundTransparency = 1
    versionText.Font = Enum.Font.Gotham
    versionText.TextSize = 11
    versionText.TextColor3 = CONFIG.UI.SECONDARY_COLOR
    versionText.TextXAlignment = Enum.TextXAlignment.Left
    versionText.Text = "v2.2 Pro"
    versionText.ZIndex = 3
    versionText.Parent = titleBar
    
    -- Minimize button
    local minimizeBtn = Instance.new('ImageButton')
    minimizeBtn.Name = 'MinimizeButton'
    minimizeBtn.Size = UDim2.new(0, 32, 0, 32)
    minimizeBtn.Position = UDim2.new(1, -82, 0, 6)
    minimizeBtn.BackgroundColor3 = CONFIG.UI.PANEL_COLOR
    minimizeBtn.BackgroundTransparency = 0.3
    minimizeBtn.BorderSizePixel = 0
    minimizeBtn.Image = "rbxassetid://7072718185"  -- Minimize icon
    minimizeBtn.ImageColor3 = CONFIG.UI.TEXT_COLOR
    minimizeBtn.ImageTransparency = 0.2
    minimizeBtn.ZIndex = 3
    minimizeBtn.Parent = titleBar
    
    local minBtnCorner = Instance.new('UICorner')
    minBtnCorner.CornerRadius = UDim.new(1, 0)
    minBtnCorner.Parent = minimizeBtn
    
    -- Close button
    local closeBtn = Instance.new('ImageButton')
    closeBtn.Name = 'CloseButton'
    closeBtn.Size = UDim2.new(0, 32, 0, 32)
    closeBtn.Position = UDim2.new(1, -42, 0, 6)
    closeBtn.BackgroundColor3 = CONFIG.UI.ERROR_COLOR
    closeBtn.BackgroundTransparency = 0.2
    closeBtn.BorderSizePixel = 0
    closeBtn.Image = "rbxassetid://7072725342"  -- Close icon
    closeBtn.ImageColor3 = CONFIG.UI.TEXT_COLOR
    closeBtn.ImageTransparency = 0.1
    closeBtn.ZIndex = 3
    closeBtn.Parent = titleBar
    
    local closeBtnCorner = Instance.new('UICorner')
    closeBtnCorner.CornerRadius = UDim.new(1, 0)
    closeBtnCorner.Parent = closeBtn
    
    -- Status panel
    local statusPanel = Instance.new('Frame')
    statusPanel.Name = 'StatusPanel'
    statusPanel.Size = UDim2.new(1, -24, 0, 95)
    statusPanel.Position = UDim2.new(0, 12, 0, 55)
    statusPanel.BackgroundColor3 = CONFIG.UI.PANEL_COLOR
    statusPanel.BorderSizePixel = 0
    statusPanel.Parent = mainFrame
    
    -- Add a stroke to the status panel
    local statusStroke = Instance.new('UIStroke')
    statusStroke.Color = CONFIG.UI.ACCENT_COLOR
    statusStroke.Transparency = 0.9
    statusStroke.Thickness = 1
    statusStroke.Parent = statusPanel
    
    local statusCorner = Instance.new('UICorner')
    statusCorner.CornerRadius = UDim.new(0, 8)
    statusCorner.Parent = statusPanel
    
    -- Animated status indicator
    local statusIndicator = Instance.new('Frame')
    statusIndicator.Name = 'StatusIndicator'
    statusIndicator.Size = UDim2.new(0, 10, 0, 10)
    statusIndicator.Position = UDim2.new(0, 18, 0, 18)
    statusIndicator.BackgroundColor3 = CONFIG.UI.ACCENT_COLOR
    statusIndicator.BorderSizePixel = 0
    statusIndicator.Parent = statusPanel
    
    -- Glow effect for indicator
    local indicatorGlow = Instance.new('ImageLabel')
    indicatorGlow.Name = 'IndicatorGlow'
    indicatorGlow.BackgroundTransparency = 1
    indicatorGlow.Size = UDim2.new(1, 12, 1, 12)
    indicatorGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
    indicatorGlow.AnchorPoint = Vector2.new(0.5, 0.5)
    indicatorGlow.Image = "rbxassetid://6014261993"
    indicatorGlow.ImageColor3 = CONFIG.UI.ACCENT_COLOR
    indicatorGlow.ImageTransparency = 0.5
    indicatorGlow.Parent = statusIndicator
    
    -- Blinking animation
    local blinkGradient = Instance.new('UIGradient')
    blinkGradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 0.3)
    })
    blinkGradient.Rotation = 90
    blinkGradient.Parent = statusIndicator
    
    -- Animate the indicator
    spawn(function()
        local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
        local tween = game:GetService("TweenService"):Create(
            blinkGradient, 
            tweenInfo, 
            {Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0.3),
                NumberSequenceKeypoint.new(1, 0)
            })}
        )
        tween:Play()
    end)
    
    local indicatorCorner = Instance.new('UICorner')
    indicatorCorner.CornerRadius = UDim.new(1, 0)
    indicatorCorner.Parent = statusIndicator
    
    -- Status text
    local statusLabel = Instance.new('TextLabel')
    statusLabel.Name = 'StatusText'
    statusLabel.Size = UDim2.new(1, -48, 0, 20)
    statusLabel.Position = UDim2.new(0, 36, 0, 13)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Font = Enum.Font.GothamSemibold
    statusLabel.TextSize = 14
    statusLabel.TextColor3 = CONFIG.UI.TEXT_COLOR
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left
    statusLabel.Text = "Initializing Farm System..."
    statusLabel.Parent = statusPanel
    
    -- Money icon
    local moneyIcon = Instance.new('ImageLabel')
    moneyIcon.Name = 'MoneyIcon'
    moneyIcon.Size = UDim2.new(0, 18, 0, 18)
    moneyIcon.Position = UDim2.new(0, 15, 0, 43)
    moneyIcon.BackgroundTransparency = 1
    moneyIcon.Image = "rbxassetid://7072721559"  -- Money icon
    moneyIcon.ImageColor3 = Color3.fromRGB(255, 220, 60)
    moneyIcon.Parent = statusPanel
    
    -- Money label
    local moneyLabel = Instance.new('TextLabel')
    moneyLabel.Name = 'MoneyText'
    moneyLabel.Size = UDim2.new(1, -48, 0, 20)
    moneyLabel.Position = UDim2.new(0, 36, 0, 42)
    moneyLabel.BackgroundTransparency = 1
    moneyLabel.Font = Enum.Font.GothamSemibold
    moneyLabel.TextSize = 14
    moneyLabel.TextColor3 = Color3.fromRGB(255, 220, 60)
    moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
    moneyLabel.Text = "Money: 0 Sheckles"
    moneyLabel.Parent = statusPanel
    
    -- Rate icon
    local rateIcon = Instance.new('ImageLabel')
    rateIcon.Name = 'RateIcon'
    rateIcon.Size = UDim2.new(0, 18, 0, 18)
    rateIcon.Position = UDim2.new(0, 15, 0, 70)
    rateIcon.BackgroundTransparency = 1
    rateIcon.Image = "rbxassetid://7072715646"  -- Chart icon
    rateIcon.ImageColor3 = CONFIG.UI.INFO_COLOR
    rateIcon.Parent = statusPanel
    
    -- Rate label
    local rateLabel = Instance.new('TextLabel')
    rateLabel.Name = 'RateText'
    rateLabel.Size = UDim2.new(1, -48, 0, 20)
    rateLabel.Position = UDim2.new(0, 36, 0, 69)
    rateLabel.BackgroundTransparency = 1
    rateLabel.Font = Enum.Font.Gotham
    rateLabel.TextSize = 14
    rateLabel.TextColor3 = CONFIG.UI.INFO_COLOR
    rateLabel.TextXAlignment = Enum.TextXAlignment.Left
    rateLabel.Text = "Rate: Calculating..."
    rateLabel.Parent = statusPanel
    
    -- Stats panel
    local statsPanel = Instance.new('Frame')
    statsPanel.Name = 'StatsPanel'
    statsPanel.Size = UDim2.new(1, -24, 0, 120)
    statsPanel.Position = UDim2.new(0, 12, 0, 160)
    statsPanel.BackgroundColor3 = CONFIG.UI.PANEL_COLOR
    statsPanel.BorderSizePixel = 0
    statsPanel.Parent = mainFrame
    
    -- Add a stroke to the stats panel
    local statsStroke = Instance.new('UIStroke')
    statsStroke.Color = CONFIG.UI.SECONDARY_COLOR
    statsStroke.Transparency = 0.9
    statsStroke.Thickness = 1
    statsStroke.Parent = statsPanel
    
    local statsCorner = Instance.new('UICorner')
    statsCorner.CornerRadius = UDim.new(0, 8)
    statsCorner.Parent = statsPanel
    
    -- Stats header with icon
    local statsIcon = Instance.new('ImageLabel')
    statsIcon.Name = 'StatsIcon'
    statsIcon.Size = UDim2.new(0, 20, 0, 20)
    statsIcon.Position = UDim2.new(0, 15, 0, 10)
    statsIcon.BackgroundTransparency = 1
    statsIcon.Image = "rbxassetid://7072707514"  -- Chart/stats icon
    statsIcon.ImageColor3 = CONFIG.UI.SECONDARY_COLOR
    statsIcon.Parent = statsPanel
    
    -- Stats title
    local statsTitle = Instance.new('TextLabel')
    statsTitle.Name = 'StatsTitle'
    statsTitle.Size = UDim2.new(1, -50, 0, 30)
    statsTitle.Position = UDim2.new(0, 40, 0, 5)
    statsTitle.BackgroundTransparency = 1
    statsTitle.Font = Enum.Font.GothamBold
    statsTitle.TextSize = 14
    statsTitle.TextColor3 = CONFIG.UI.SECONDARY_COLOR
    statsTitle.TextXAlignment = Enum.TextXAlignment.Left
    statsTitle.Text = "Farm Analytics"
    statsTitle.Parent = statsPanel
    
    -- Stats container
    local statsContainer = Instance.new('Frame')
    statsContainer.Name = 'StatsContainer'
    statsContainer.Size = UDim2.new(1, -30, 0, 80)
    statsContainer.Position = UDim2.new(0, 15, 0, 35)
    statsContainer.BackgroundTransparency = 1
    statsContainer.Parent = statsPanel
    
    -- Stats grid layout
    local statsLayout = Instance.new('UIGridLayout')
    statsLayout.CellPadding = UDim2.new(0, 12, 0, 8)
    statsLayout.CellSize = UDim2.new(0.5, -6, 0, 25)
    statsLayout.Parent = statsContainer
    
    -- Create stat labels with icons
    local function createStatLabel(name, value, iconId, iconColor)
        local statFrame = Instance.new('Frame')
        statFrame.Name = name .. "Frame"
        statFrame.BackgroundColor3 = CONFIG.UI.BACKGROUND_COLOR
        statFrame.BackgroundTransparency = 0.7
        statFrame.BorderSizePixel = 0
        statFrame.Parent = statsContainer
        
        local statCorner = Instance.new('UICorner')
        statCorner.CornerRadius = UDim.new(0, 6)
        statCorner.Parent = statFrame
        
        -- Icon for the stat
        local statIcon = Instance.new('ImageLabel')
        statIcon.Name = name .. "Icon"
        statIcon.Size = UDim2.new(0, 16, 0, 16)
        statIcon.Position = UDim2.new(0, 8, 0, 4)
        statIcon.BackgroundTransparency = 1
        statIcon.Image = iconId
        statIcon.ImageColor3 = iconColor or CONFIG.UI.TEXT_COLOR
        statIcon.Parent = statFrame
        
        -- Label for the stat
        local statLabel = Instance.new('TextLabel')
        statLabel.Name = name .. "Label"
        statLabel.Size = UDim2.new(1, -32, 1, 0)
        statLabel.Position = UDim2.new(0, 30, 0, 0)
        statLabel.BackgroundTransparency = 1
        statLabel.Font = Enum.Font.Gotham
        statLabel.TextSize = 12
        statLabel.TextColor3 = CONFIG.UI.TEXT_COLOR
        statLabel.TextXAlignment = Enum.TextXAlignment.Left
        statLabel.Text = name .. ": " .. value
        statLabel.Parent = statFrame
        
        return statLabel
    end
    
    -- Create stat labels with appropriate icons
    UI.statsLabels.plantsCollected = createStatLabel("Collected", "0", "rbxassetid://7733658133", Color3.fromRGB(80, 220, 100))
    UI.statsLabels.seedsPlanted = createStatLabel("Planted", "0", "rbxassetid://7733924046", Color3.fromRGB(80, 220, 100))
    UI.statsLabels.petsHatched = createStatLabel("Pets", "0", "rbxassetid://7733774602", Color3.fromRGB(180, 120, 255))
    UI.statsLabels.treesRemoved = createStatLabel("Removed", "0", "rbxassetid://7733796917", Color3.fromRGB(255, 100, 100))
    UI.statsLabels.sessionTime = createStatLabel("Runtime", "0:00:00", "rbxassetid://7733799170", Color3.fromRGB(70, 170, 255))
    UI.statsLabels.totalProfit = createStatLabel("Profit", "0", "rbxassetid://7072706796", Color3.fromRGB(255, 215, 0))
    
    -- Logs panel
    local logsPanel = Instance.new('Frame')
    logsPanel.Name = 'LogsPanel'
    logsPanel.Size = UDim2.new(1, -24, 0, 170)
    logsPanel.Position = UDim2.new(0, 12, 0, 290)
    logsPanel.BackgroundColor3 = CONFIG.UI.PANEL_COLOR
    logsPanel.BorderSizePixel = 0
    logsPanel.Parent = mainFrame
    
    -- Add a stroke to the logs panel
    local logsStroke = Instance.new('UIStroke')
    logsStroke.Color = CONFIG.UI.ACCENT_COLOR
    logsStroke.Transparency = 0.9
    logsStroke.Thickness = 1
    logsStroke.Parent = logsPanel
    
    local logsCorner = Instance.new('UICorner')
    logsCorner.CornerRadius = UDim.new(0, 8)
    logsCorner.Parent = logsPanel
    
    -- Logs header with icon
    local logsIcon = Instance.new('ImageLabel')
    logsIcon.Name = 'LogsIcon'
    logsIcon.Size = UDim2.new(0, 20, 0, 20)
    logsIcon.Position = UDim2.new(0, 15, 0, 10)
    logsIcon.BackgroundTransparency = 1
    logsIcon.Image = "rbxassetid://7733676270"  -- Console/log icon
    logsIcon.ImageColor3 = CONFIG.UI.ACCENT_COLOR
    logsIcon.Parent = logsPanel
    
    -- Logs title
    local logsTitle = Instance.new('TextLabel')
    logsTitle.Name = 'LogsTitle'
    logsTitle.Size = UDim2.new(1, -50, 0, 30)
    logsTitle.Position = UDim2.new(0, 40, 0, 5)
    logsTitle.BackgroundTransparency = 1
    logsTitle.Font = Enum.Font.GothamBold
    logsTitle.TextSize = 14
    logsTitle.TextColor3 = CONFIG.UI.ACCENT_COLOR
    logsTitle.TextXAlignment = Enum.TextXAlignment.Left
    logsTitle.Text = "Activity Log"
    logsTitle.Parent = logsPanel
    
    -- Logs scrolling frame with dark background
    local logsBackground = Instance.new('Frame')
    logsBackground.Name = 'LogsBackground'
    logsBackground.Size = UDim2.new(1, -20, 1, -45)
    logsBackground.Position = UDim2.new(0, 10, 0, 35)
    logsBackground.BackgroundColor3 = CONFIG.UI.BACKGROUND_COLOR
    logsBackground.BorderSizePixel = 0
    logsBackground.Parent = logsPanel
    
    local logsBackgroundCorner = Instance.new('UICorner')
    logsBackgroundCorner.CornerRadius = UDim.new(0, 6)
    logsBackgroundCorner.Parent = logsBackground
    
    local logsScroll = Instance.new('ScrollingFrame')
    logsScroll.Name = 'LogsScroll'
    logsScroll.Size = UDim2.new(1, -10, 1, -10)
    logsScroll.Position = UDim2.new(0, 5, 0, 5)
    logsScroll.BackgroundTransparency = 1
    logsScroll.BorderSizePixel = 0
    logsScroll.ScrollBarThickness = 4
    logsScroll.ScrollBarImageColor3 = CONFIG.UI.ACCENT_COLOR
    logsScroll.ScrollBarImageTransparency = 0.7
    logsScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    logsScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    logsScroll.Parent = logsBackground
    
    -- Logs list layout
    local logsLayout = Instance.new('UIListLayout')
    logsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    logsLayout.Padding = UDim.new(0, 4)
    logsLayout.Parent = logsScroll
    
    -- Make window draggable
    local isDragging = false
    local dragStart
    local startPos
    
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
            dragStart = input.Position
            startPos = mainFrame.Position
        end
    end)
    
    titleBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
        end
    end)
    
    titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and isDragging then
            local delta = input.Position - dragStart
            mainFrame.Position = UDim2.new(
                startPos.X.Scale, 
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
    
    -- Minimize button functionality with improved animation
    local isMinimized = false
    minimizeBtn.MouseButton1Click:Connect(function()
        isMinimized = not isMinimized
        
        if isMinimized then
            -- Create a nice animation sequence
            statsPanel.Visible = false
            logsPanel.Visible = false
            
            -- Tween the main frame to smaller size
            local tween = game:GetService("TweenService"):Create(
                mainFrame, 
                TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
                {Size = UDim2.new(0, 400, 0, 160)}
            )
            tween:Play()
            
            minimizeBtn.Image = "rbxassetid://7072720870" -- Expand icon
        else
            -- Tween back to normal size
            local tween = game:GetService("TweenService"):Create(
                mainFrame, 
                TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
                {Size = UDim2.new(0, 400, 0, 480)}
            )
            tween:Play()
            
            -- Show panels after tween completes
            task.delay(0.25, function()
                statsPanel.Visible = true
                logsPanel.Visible = true
            end)
            
            minimizeBtn.Image = "rbxassetid://7072718185" -- Minimize icon
        end
    end)
    
    -- Hover effect for buttons
    local function createButtonHoverEffect(button)
        local originalTransparency = button.BackgroundTransparency
        
        button.MouseEnter:Connect(function()
            game:GetService("TweenService"):Create(
                button,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {BackgroundTransparency = originalTransparency - 0.2}
            ):Play()
        end)
        
        button.MouseLeave:Connect(function()
            game:GetService("TweenService"):Create(
                button,
                TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {BackgroundTransparency = originalTransparency}
            ):Play()
        end)
    end
    
    createButtonHoverEffect(minimizeBtn)
    createButtonHoverEffect(closeBtn)
    
    -- Close button functionality
    closeBtn.MouseButton1Click:Connect(function()
        -- Fade out animation
        local tween = game:GetService("TweenService"):Create(
            screenGui, 
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {Transparency = 1}
        )
        tween:Play()
        
        tween.Completed:Connect(function()
            screenGui:Destroy()
            UI.mainFrame = nil
        end)
    end)
    
    -- Save references
    UI.mainFrame = mainFrame
    UI.statusLabel = statusLabel
    UI.statusIndicator = statusIndicator
    UI.moneyLabel = moneyLabel
    UI.rateLabel = rateLabel
    UI.logContainer = logsScroll
    
    setupMoneyWatch()
    
    -- Log initial message
    log("System", "Farm interface ready for operation")
    
    return screenGui
end

-- Add log entry to UI with an improved style
function addLogToUI(entry)
    if not UI.logContainer then return end
    
    -- Create log entry frame
    local entryFrame = Instance.new('Frame')
    entryFrame.Name = 'LogEntry_' .. entry.timestamp
    entryFrame.Size = UDim2.new(1, 0, 0, 22)
    entryFrame.BackgroundTransparency = 0.95
    entryFrame.BackgroundColor3 = CONFIG.UI.PANEL_COLOR
    entryFrame.BorderSizePixel = 0
    entryFrame.LayoutOrder = -entry.timestamp -- Newest logs at top
    entryFrame.Parent = UI.logContainer
    
    -- Add subtle rounded corners
    local entryCorner = Instance.new('UICorner')
    entryCorner.CornerRadius = UDim.new(0, 4)
    entryCorner.Parent = entryFrame
    
    -- Time label
    local timeLabel = Instance.new('TextLabel')
    timeLabel.Name = 'TimeLabel'
    timeLabel.Size = UDim2.new(0, 45, 1, 0)
    timeLabel.Position = UDim2.new(0, 5, 0, 0)
    timeLabel.BackgroundTransparency = 1
    timeLabel.Font = Enum.Font.Code
    timeLabel.TextSize = 11
    timeLabel.TextColor3 = Color3.fromRGB(160, 160, 180)
    timeLabel.TextXAlignment = Enum.TextXAlignment.Left
    timeLabel.Text = entry.time
    timeLabel.Parent = entryFrame
    
    -- Category label with color coding and badge
    local categoryBadge = Instance.new('Frame')
    categoryBadge.Name = 'CategoryBadge'
    categoryBadge.Size = UDim2.new(0, 2, 0, 16)
    categoryBadge.Position = UDim2.new(0, 52, 0, 3)
    categoryBadge.BorderSizePixel = 0
    
    -- Color based on category
    if entry.isError then
        categoryBadge.BackgroundColor3 = CONFIG.UI.ERROR_COLOR
    elseif entry.category == "Warning" then
        categoryBadge.BackgroundColor3 = CONFIG.UI.WARNING_COLOR
    elseif entry.category == "Success" then
        categoryBadge.BackgroundColor3 = CONFIG.UI.ACCENT_COLOR
    elseif entry.category == "Farm" or entry.category == "Seed" or entry.category == "Plant" then
        categoryBadge.BackgroundColor3 = Color3.fromRGB(80, 220, 100)
    elseif entry.category == "Pet" or entry.category == "Egg" then
        categoryBadge.BackgroundColor3 = Color3.fromRGB(180, 120, 255)
    elseif entry.category == "Money" or entry.category == "Sell" then
        categoryBadge.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
    else
        categoryBadge.BackgroundColor3 = CONFIG.UI.INFO_COLOR
    end
    
    categoryBadge.Parent = entryFrame
    
    local categoryLabel = Instance.new('TextLabel')
    categoryLabel.Name = 'CategoryLabel'
    categoryLabel.Size = UDim2.new(0, 70, 1, 0)
    categoryLabel.Position = UDim2.new(0, 58, 0, 0)
    categoryLabel.BackgroundTransparency = 1
    categoryLabel.Font = Enum.Font.GothamBold
    categoryLabel.TextSize = 11
    categoryLabel.TextColor3 = categoryBadge.BackgroundColor3
    categoryLabel.TextXAlignment = Enum.TextXAlignment.Left
    categoryLabel.Text = entry.category
    categoryLabel.Parent = entryFrame
    
    -- Message label
    local messageLabel = Instance.new('TextLabel')
    messageLabel.Name = 'MessageLabel'
    messageLabel.Size = UDim2.new(1, -135, 1, 0)
    messageLabel.Position = UDim2.new(0, 130, 0, 0)
    messageLabel.BackgroundTransparency = 1
    messageLabel.Font = Enum.Font.Gotham
    messageLabel.TextSize = 11
    messageLabel.TextColor3 = CONFIG.UI.TEXT_COLOR
    messageLabel.TextXAlignment = Enum.TextXAlignment.Left
    messageLabel.TextWrapped = true
    messageLabel.Text = entry.message
    messageLabel.Parent = entryFrame
    
    -- Apply alternating row effect for better readability
    if entry.timestamp % 2 == 0 then
        entryFrame.BackgroundTransparency = 0.9
    end
    
    -- Limit number of visible log entries
    local children = UI.logContainer:GetChildren()
    local count = 0
    for _, child in pairs(children) do
        if child:IsA("Frame") then
            count = count + 1
        end
    end
    
    if count > 50 then
        local oldest = nil
        local oldestOrder = -math.huge
        
        for _, child in pairs(children) do
            if child:IsA("Frame") and child.LayoutOrder > oldestOrder then
                oldest = child
                oldestOrder = child.LayoutOrder
            end
        end
        
        if oldest then
            oldest:Destroy()
        end
    end
    
    -- Auto-scroll to keep newest logs visible
    UI.logContainer.CanvasPosition = Vector2.new(0, 0)
    
    -- Apply entry animation
    entryFrame.BackgroundTransparency = 1
    entryFrame.Position = UDim2.new(0.05, 0, 0, 0)
    
    game:GetService("TweenService"):Create(
        entryFrame,
        TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {BackgroundTransparency = entry.timestamp % 2 == 0 and 0.9 or 0.95, Position = UDim2.new(0, 0, 0, 0)}
    ):Play()
end

function setupMoneyWatch()
    local sheckles = plr:WaitForChild('leaderstats', 30):WaitForChild('Sheckles', 30)
    
    -- Initialize money stats
    STATS.moneyAtStart = sheckles.Value
    STATS.currentMoney = sheckles.Value
    
    local lastValue = sheckles.Value
    local lastTime = tick()
    
    if sheckles then
        sheckles:GetPropertyChangedSignal('Value'):Connect(function()
            local newValue = sheckles.Value
            local oldValue = lastValue
            
            -- Update stats
            STATS.currentMoney = newValue
            STATS.moneyGained = newValue - STATS.moneyAtStart
            
            -- Calculate money rate
            local now = tick()
            local deltaValue = newValue - oldValue
            local elapsed = now - lastTime
            
            if elapsed > 0 then
                local rate = deltaValue / (elapsed / 60)
                STATS.moneyPerMinute = rate
                
                if UI.rateLabel then
                    UI.rateLabel.Text = string.format("Rate: %s/min", formatNumber(rate))
                end
            end
            
            -- Log significant changes
            if math.abs(deltaValue) > 100 then
                if deltaValue > 0 then
                    log("Money", "Gained " .. formatNumber(deltaValue) .. " Sheckles")
                else
                    log("Money", "Spent " .. formatNumber(math.abs(deltaValue)) .. " Sheckles")
                end
            end
            
            -- Update display
            if UI.moneyLabel then
                UI.moneyLabel.Text = "Money: " .. formatNumber(newValue) .. " Sheckles"
            end
            
            -- Update profit in stats
            if UI.statsLabels.totalProfit then
                UI.statsLabels.totalProfit.Text = "Profit: " .. formatNumber(STATS.moneyGained)
            end
            
            lastValue = newValue
            lastTime = now
        end)
    end
    
    -- Update session time continuously
    task.spawn(function()
        while true do
            task.wait(1)
            updateSessionTime()
        end
    end)
end

-- Format numbers for display (1000 -> 1K, 1000000 -> 1M)
function formatNumber(num)
    if num >= 1000000000 then
        return string.format("%.1fB", num / 1000000000)
    elseif num >= 1000000 then
        return string.format("%.1fM", num / 1000000)
    elseif num >= 1000 then
        return string.format("%.1fK", num / 1000)
    else
        return tostring(math.floor(num))
    end
end

function updateSessionTime()
    if not UI.statsLabels.sessionTime then return end
    
    local sessionDuration = tick() - STATS.startTime
    local hours = math.floor(sessionDuration / 3600)
    local minutes = math.floor((sessionDuration % 3600) / 60)
    local seconds = math.floor(sessionDuration % 60)
    
    UI.statsLabels.sessionTime.Text = string.format("Session: %d:%02d:%02d", hours, minutes, seconds)
end

function updateStats()
    if not UI.statsLabels then return end
    
    UI.statsLabels.plantsCollected.Text = "Collected: " .. STATS.plantsCollected
    UI.statsLabels.seedsPlanted.Text = "Planted: " .. STATS.seedsPlanted
    UI.statsLabels.petsHatched.Text = "Hatched: " .. STATS.petsHatched
    UI.statsLabels.treesRemoved.Text = "Removed: " .. STATS.treesRemoved
    UI.statsLabels.totalProfit.Text = "Profit: " .. formatNumber(STATS.moneyGained)
    
    updateSessionTime()
end

function updateStatus(text)
    log("Status", text)
end

function updateMoney(value)
    STATS.currentMoney = value
    if UI.moneyLabel then
        UI.moneyLabel.Text = 'Money: ' .. formatNumber(value) .. " Sheckles"
    end
end

function updateInfo(value)
    if UI.rateLabel then
        UI.rateLabel.Text = value
    end
end

-- Cache for getData function to reduce API calls
local dataCache = {
    lastFetch = 0,
    data = nil
}

function getData()
    -- Only fetch new data every 2 seconds max
    if dataCache.data and (tick() - dataCache.lastFetch > 5) then
        return dataCache.data
    end
    
    local success, data = pcall(function()
        return dataService:GetData()
    end)
    
    if success then
        dataCache.data = data
        dataCache.lastFetch = tick()
        return data
    end
    
    log("Error", "Failed to get game data - retrying", true)
    Utility.safeTaskWait(1)
    return getData()
end

-- Replace the buySeeds function
function buySeeds()
    warn('[Farm]: Buying seeds ...')
    updateStatus('[Farm]: Buying seeds ...')
    
    -- Check if we're in tree removal mode
    if IS_REMOVING_TREES then
        log("Farm", "Currently removing trees - SKIPPING seed purchase completely")
        return
    end
    
    local playerData = getData()
    local seedStocks = playerData.SeedStock.Stocks
    local seedList = {}
    local playerSheckles = playerData.Sheckles
    
    -- Check tree count
    local plantsPhysical = Farm.Important.Plants_Physical:GetChildren()
    local totalTreeCount = #plantsPhysical
    
    for seedName, data in next, seedStocks do
        local seedInfo = seedData[seedName]
        if not blacklistSeeds[seedName] and data.Stock > 0 and playerData.Sheckles >= seedInfo.Price then
            if (seedInfo.SeedRarity == "Common" or seedInfo.SeedRarity == "Uncommon") then
                if playerSheckles >= 10000 then
                    log("Seed", "Skipping " .. seedName .. " (" .. seedInfo.SeedRarity .. ") - Common/Uncommon seeds are skipped")
                    continue
                else
                    log("Seed", "New account detected, allowing Common/Uncommon seeds purchase")
                    -- Allow purchase to continue for new accounts
                end
            end
            
            -- Still apply other money thresholds for higher rarities
            local shouldBuy = true
            if seedInfo.SeedRarity == "Rare" and playerSheckles >= CONFIG.MONEY_THRESHOLDS.SEED_BUYING.STOP_RARE then
                shouldBuy = false
            elseif seedInfo.SeedRarity == "Epic" and playerSheckles >= CONFIG.MONEY_THRESHOLDS.SEED_BUYING.STOP_EPIC then
                shouldBuy = false
            end
            
            if shouldBuy then
                table.insert(seedList, {
                    Name = seedName,
                    Stock = data.Stock,
                    Price = seedInfo.Price,
                    Rarity = seedInfo.SeedRarity
                })
            end
        end
    end

    table.sort(seedList, function(a, b)
        return (CONFIG.RARITY_ORDER[a.Rarity] or 0) > (CONFIG.RARITY_ORDER[b.Rarity] or 0)
    end)

    for _, seed in next, seedList do
        if not CONFIG.PLANT_FILTER[seed.Rarity] then continue end
        log("Seed", "Buying " .. seed.Name .. " (" .. seed.Rarity .. ") for " .. formatNumber(seed.Price))
        buySeedStock:FireServer(seed.Name)
        task.wait()
    end
end

-- Replace the plantSeeds function with the same logic
function plantSeeds()
    warn('[Farm]: Planting ...')
    updateStatus('[Farm]: Planting ...')
    
    local plantsPhysical = Farm.Important.Plants_Physical:GetChildren()
    local currentTrees = #plantsPhysical
    
    -- Check tree limit
    if currentTrees >= CONFIG.MAX_TREES then
        log("Farm", "Max tree limit reached (" .. currentTrees .. "/" .. CONFIG.MAX_TREES .. ")")
        updateStatus('[Farm]: Max tree limit reached (' .. currentTrees .. '/' .. CONFIG.MAX_TREES .. ')')
        return
    end
    
    local availableSpots = CONFIG.MAX_TREES - currentTrees
    log("Farm", "Available spots: " .. availableSpots .. "/" .. CONFIG.MAX_TREES)
    
    local character = Utility.getCharacter()
    local backpackItems = plr.Backpack:GetChildren()
    local location = Farm.Important.Plant_Locations:GetChildren()[math.random(1,2)]
    local playerData = getData()
    local playerSheckles = playerData.Sheckles
    
    if not location then
        log("Error", "No planting location found", true)
        return 
    end
    
    -- Sort seeds by rarity
    local seedsToPlant = {}
    for _, tool in next, backpackItems do
        local itemType = tool:GetAttribute('ItemType')
        local itemName = tool:GetAttribute('ItemName')
        local seedInfo = seedData[itemName]

        if itemType == 'Seed' and seedInfo then
            -- Verify seed is allowed by plant filter
            if not CONFIG.PLANT_FILTER[seedInfo.SeedRarity] then 
                continue 
            end
            
            -- For new accounts with low money, allow Common/Uncommon seeds planting
            if (seedInfo.SeedRarity == "Common" or seedInfo.SeedRarity == "Uncommon") then
                if playerSheckles >= 20000 then
                    log("Plant", "Skipping " .. itemName .. " (" .. seedInfo.SeedRarity .. ") - Common/Uncommon seeds are skipped")
                    continue
                else
                    log("Plant", "New account detected, allowing Common/Uncommon seeds planting")
                    -- Allow planting to continue for new accounts
                end
            end
            
            -- Apply money thresholds for higher rarities
            local shouldPlant = true
            if seedInfo.SeedRarity == "Rare" and playerSheckles >= CONFIG.MONEY_THRESHOLDS.SEED_BUYING.STOP_RARE then
                shouldPlant = false
            elseif seedInfo.SeedRarity == "Epic" and playerSheckles >= CONFIG.MONEY_THRESHOLDS.SEED_BUYING.STOP_EPIC then
                shouldPlant = false
            end
            
            if shouldPlant then
                table.insert(seedsToPlant, {
                    tool = tool, 
                    name = itemName, 
                    rarity = seedInfo.SeedRarity,
                    rarityValue = CONFIG.RARITY_ORDER[seedInfo.SeedRarity] or 0
                })
            end
        end
    end
    
    -- Sort by rarity (highest first)
    table.sort(seedsToPlant, function(a, b)
        return a.rarityValue > b.rarityValue
    end)
    
    -- Limit seeds to available spots
    if #seedsToPlant > availableSpots then
        seedsToPlant = {unpack(seedsToPlant, 1, availableSpots)}
    end
    
    if #seedsToPlant == 0 then
        log("Farm", "No suitable seeds to plant")
        return
    end
    
    log("Farm", "Found " .. #seedsToPlant .. " seeds to plant")
    
    -- First teleport to the planting location
    local distance = (character.HumanoidRootPart.Position - location.Position).Magnitude
    if distance > 10 then
        character.HumanoidRootPart.CFrame = location.CFrame * CFrame.new(0, -6.5, 0)
        task.wait(0.5) -- Wait for character to stabilize
    end
    
    local plantedCount = 0
    local previousBackpackCount = #plr.Backpack:GetChildren()
    
    for _, seedData in next, seedsToPlant do
        local tool = seedData.tool
        local itemName = seedData.name
        
        if not tool or not tool.Parent then
            continue -- Skip if tool is gone
        end
        
        local arguments = {
            [1] = location.Position,
            [2] = itemName
        }

        -- Equip tool
        pcall(function()
            character.Humanoid:EquipTool(tool)
            task.wait(0.05)
        end)
        
        -- Move to planting location if needed
        distance = (character.HumanoidRootPart.Position - location.Position).Magnitude
        if distance > 10 then
            character.HumanoidRootPart.CFrame = location.CFrame * CFrame.new(0, -6.5, 0)
            task.wait(0.2)
        end
        
        -- Try to plant (maximum 3 attempts per seed)
        local planted = false
        for attempt = 1, 3 do
            -- Check if tool is still available
            if not tool or not tool.Parent then
                planted = true
                break
            end
            
            -- Fire planting event
            plantRE:FireServer(unpack(arguments))
            task.wait(0.2)
            
            -- Check if backpack count changed (indicates seed was used)
            local currentBackpackCount = #plr.Backpack:GetChildren() + #character:GetChildren() - 1
            if currentBackpackCount < previousBackpackCount then
                planted = true
                previousBackpackCount = currentBackpackCount
                break
            end
            
            -- Try with slightly different position if failed
            if not planted and attempt < 3 then
                local offset = Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
                arguments[1] = location.Position + offset
                task.wait(0.1)
            end
        end
        
        if planted then
            plantedCount = plantedCount + 1
            if plantedCount % 5 == 0 or plantedCount == #seedsToPlant then
                log("Farm", "Planted " .. plantedCount .. "/" .. #seedsToPlant .. " seeds")
                updateStatus(string.format('[Farm]: Planted %d/%d seeds', plantedCount, #seedsToPlant))
            end
        else
            log("Warning", "Failed to plant " .. itemName)
        end
        
        task.wait(0.05)
    end
    
    if plantedCount > 0 then
        STATS.seedsPlanted = STATS.seedsPlanted + plantedCount
        log("Farm", "Successfully planted " .. plantedCount .. " seeds")
        
        task.wait(1)
        local newTreeCount = #Farm.Important.Plants_Physical:GetChildren()
        log("Farm", "Current tree count: " .. newTreeCount .. "/" .. CONFIG.MAX_TREES)
        
        updateStats()
    else
        log("Error", "Failed to plant any seeds", true)
    end
end

function buyMoon()
    local bloodMoonStock = getData().EventShopStock.Stocks
    local sorted = {}
    for name in next, bloodMoonStock do
        if stockdata[name].SeedRarity == "Mythical" or stockdata[name].SeedRarity == "Divine" then
            table.insert(sorted, {
                name = name,
                rarity = stockdata[name].SeedRarity
            })
        end
    end

    if #sorted == 0 then
        log("Farm", "No seeds to buy from Blood Moon")
        return
    end

    table.sort(sorted, function(a, b)
        return CONFIG.RARITY_ORDER[a.rarity] > CONFIG.RARITY_ORDER[b.rarity]
    end)

    for _, v in next, sorted do
        local remote = game:GetService("ReplicatedStorage").GameEvents.BuyEventShopStock

        local arguments = {
            [1] = v.name
        }

        remote:FireServer(unpack(arguments))
    end
end

-- Update the buyEggs function with threshold logic
function buyEggs()
    local objectsPhysical = Farm.Important.Objects_Physical:GetChildren()
    if #objectsPhysical >= 3 then return end

    local character = Utility.getCharacter()
    local backpackItems = plr.Backpack:GetChildren()
    local raphael = NPCs:FindFirstChild('Raphael')

    if not raphael then 
        log("Error", "Raphael NPC not found - cannot buy eggs", true)
        return
    end

    local playerData = getData()
    local playerSheckles = playerData.Sheckles
    local eggStocks = playerData.PetEggStock.Stocks
    local eggList = {}

    for index, eggData in next, eggStocks do
        local fullData = petEggData[eggData.EggName]
        if not fullData then continue end
        
        -- Check if player has enough money and apply threshold logic
        if eggData.Stock > 0 and playerData.Sheckles >= fullData.Price then
            local shouldBuy = true
            
            if fullData.EggRarity == "Common" and playerSheckles >= CONFIG.MONEY_THRESHOLDS.EGG_BUYING.STOP_COMMON then
                shouldBuy = false
            elseif fullData.EggRarity == "Uncommon" and playerSheckles >= CONFIG.MONEY_THRESHOLDS.EGG_BUYING.STOP_UNCOMMON then
                shouldBuy = false
            elseif fullData.EggRarity == "Rare" and playerSheckles >= CONFIG.MONEY_THRESHOLDS.EGG_BUYING.STOP_RARE then
                shouldBuy = false
            elseif fullData.EggRarity == "Epic" and playerSheckles >= CONFIG.MONEY_THRESHOLDS.EGG_BUYING.STOP_EPIC then
                shouldBuy = false
            end
            
            if shouldBuy then
                table.insert(eggList, {
                    Index = index,
                    Name = eggData.EggName or 'Unknown',
                    Price = fullData.Price,
                    Rarity = fullData.EggRarity or 'Common'
                })
            end
        end
    end

    table.sort(eggList, function(a, b)
        local rankA = CONFIG.RARITY_ORDER[a.Rarity] or 0
        local rankB = CONFIG.RARITY_ORDER[b.Rarity] or 0
        if rankA == rankB then
            return a.Price > b.Price
        else
            return rankA > rankB
        end
    end)

    local location = raphael.HumanoidRootPart.CFrame
    local distance = (character.HumanoidRootPart.Position - location.Position).Magnitude

    if distance > 10 then
        repeat
            distance = (character.HumanoidRootPart.Position - location.Position).Magnitude
            character.HumanoidRootPart.CFrame = location
            Utility.safeTaskWait(1)
        until distance <= 10
    end

    for _, egg in ipairs(eggList) do
        updateStatus(string.format('[Egg]: Buying %s (Rarity: %s, Price: %d)', egg.Name, egg.Rarity, egg.Price))
        log("Egg", string.format("Buying %s (Rarity: %s, Price: %s)", egg.Name, egg.Rarity, formatNumber(egg.Price)))
        buyPetEgg:FireServer(egg.Index)
        task.wait(0)
    end
end
-- sell Egg


-- Simplified destroyTrees function for more reliable tree removal
function destroyTrees()
    log("Farm", "============== TREE REMOVAL PROCESS STARTED ==============")
    log("Farm", "Checking trees for removal...")
    
    local character = Utility.getCharacter()
    local plantsPhysical = Farm.Important.Plants_Physical:GetChildren()
    local backpackItems = plr.Backpack:GetChildren()
    local playerData = getData()
    local playerSheckles = playerData.Sheckles
    local totalTreeCount = #plantsPhysical
    
    saveTreeState(totalTreeCount)
    
    if totalTreeCount >= CONFIG.MAX_TREES then
        IS_MAX_TREES = true
        log("Farm", "Tree count at or above max: " .. totalTreeCount .. "/" .. CONFIG.MAX_TREES)
    else
        IS_MAX_TREES = false
        log("Farm", "Tree count below max: " .. totalTreeCount .. "/" .. CONFIG.MAX_TREES)
    end
    
    if totalTreeCount == 0 then
        log("Farm", "No trees to check")
        IS_REMOVING_TREES = false
        return
    end
    
    local treesOverLimit = math.max(0, totalTreeCount - CONFIG.MAX_TREES)
    
    local hasBetterSeeds = false
    local hasDivineSeeds = false
    local hasMythicalSeeds = false
    local hasLegendarySeeds = false
    
    for _, tool in next, backpackItems do
        local itemType = tool:GetAttribute('ItemType')
        local itemName = tool:GetAttribute('ItemName')
        if not (itemType and itemName) then continue end
        
        local seedInfo = seedData[itemName]
        if itemType == 'Seed' and seedInfo then
            if seedInfo.SeedRarity == "Divine" then
                hasDivineSeeds = true
                hasBetterSeeds = true
            elseif seedInfo.SeedRarity == "Mythical" then
                hasMythicalSeeds = true
                hasBetterSeeds = true
            elseif seedInfo.SeedRarity == "Legendary" then
                hasLegendarySeeds = true
                hasBetterSeeds = true
            end
        end
    end
    
    if treesOverLimit <= 0 and not hasBetterSeeds then
        log("Farm", "Tree count is at or below limit and no better seeds found - no removal needed")
        IS_REMOVING_TREES = false
        return
    end
    
    if totalTreeCount < 50 and playerSheckles < 50000 then
        log("Farm", "Trees below 50 and money below 50k, preserving trees for new account")
        IS_REMOVING_TREES = false
        return
    end
    
    if totalTreeCount < CONFIG.MAX_TREES and playerSheckles < 100000 and not hasBetterSeeds then
        log("Farm", "Money too low for tree optimization")
        IS_REMOVING_TREES = false
        return
    end
    
    IS_REMOVING_TREES = true
    
    if treesOverLimit > 0 then
        log("Farm", " Need to remove " .. treesOverLimit .. " trees to reach limit")
    else
        log("Farm", "Tree count is at/below limit but found better seeds - will replace lower rarity trees")
    end
    
    log("Farm", "Scanning and categorizing trees by rarity...")
    local commonTrees = {}
    local uncommonTrees = {}
    local rareTrees = {}
    local epicTrees = {}
    local legendaryTrees = {}
    local mythicalTrees = {}
    local divineTrees = {}
    local unknownTrees = {}
    
    for _, plant in next, plantsPhysical do
        if not plant.PrimaryPart then 
            log("Warning", "Skipping tree without PrimaryPart: " .. plant.Name)
            continue 
        end
        
        local plantTime = plant:GetAttribute("PlantTime")
        if plantTime and (tick() - plantTime) < 5 then
            log("Farm", "Skipping newly planted tree: " .. plant.Name)
            continue
        end
        
        local info = seedData[plant.Name]
        if not info then 
            log("Warning", "Unknown tree type: " .. plant.Name .. " (no seed data)")
            table.insert(unknownTrees, plant)
            continue 
        end
        
        local seedRarity = info.SeedRarity
        if seedRarity == "Common" then
            table.insert(commonTrees, plant)
        elseif seedRarity == "Uncommon" then
            table.insert(uncommonTrees, plant)
        elseif seedRarity == "Rare" then
            table.insert(rareTrees, plant)
        elseif seedRarity == "Epic" then
            table.insert(epicTrees, plant)
        elseif seedRarity == "Legendary" then
            table.insert(legendaryTrees, plant)
        elseif seedRarity == "Mythical" then
            table.insert(mythicalTrees, plant)
        elseif seedRarity == "Divine" then
            table.insert(divineTrees, plant)
        else
            table.insert(unknownTrees, plant)
        end
    end
    
    log("Farm", " Found " .. #commonTrees .. " Common trees")
    log("Farm", " Found " .. #uncommonTrees .. " Uncommon trees")
    log("Farm", " Found " .. #rareTrees .. " Rare trees")
    log("Farm", " Found " .. #epicTrees .. " Epic trees")
    log("Farm", " Found " .. #legendaryTrees .. " Legendary trees")
    log("Farm", " Found " .. #mythicalTrees .. " Mythical trees")
    log("Farm", " Found " .. #divineTrees .. " Divine trees")
    log("Farm", " Found " .. #unknownTrees .. " Unknown trees")
    
    local treesToRemove = {}
    local removalTarget = treesOverLimit
    
    if treesOverLimit <= 0 and hasBetterSeeds then
        if hasDivineSeeds then
            removalTarget = math.min(5, #backpackItems) 
            log("Farm", " Planning to replace " .. removalTarget .. " trees with Divine seeds")
        elseif hasMythicalSeeds then
            removalTarget = math.min(3, #backpackItems) 
            log("Farm", " Planning to replace " .. removalTarget .. " trees with Mythical seeds")
        elseif hasLegendarySeeds then
            removalTarget = math.min(2, #backpackItems) 
            log("Farm", " Planning to replace " .. removalTarget .. " trees with Legendary seeds")
        end
    end
    
    if #commonTrees > 0 or #uncommonTrees > 0 or #rareTrees > 0 then
        log("Farm", "PHASE 1: Removing lower rarity trees first...")
        
        for i, tree in ipairs(commonTrees) do
            table.insert(treesToRemove, {tree = tree, rarity = "Common"})
            if #treesToRemove >= removalTarget then
                log("Farm", "Target reached with Common trees")
                break
            end
        end
        
        if #treesToRemove < removalTarget and #uncommonTrees > 0 then
            log("Farm", "Still need more trees, removing Uncommon trees...")
            for i, tree in ipairs(uncommonTrees) do
                table.insert(treesToRemove, {tree = tree, rarity = "Uncommon"})
                if #treesToRemove >= removalTarget then
                    log("Farm", "Target reached with Uncommon trees")
                    break
                end
            end
        end
        
        if #treesToRemove < removalTarget and #rareTrees > 0 then
            log("Farm", "Still need more trees, removing Rare trees...")
            for i, tree in ipairs(rareTrees) do
                table.insert(treesToRemove, {tree = tree, rarity = "Rare"})
                if #treesToRemove >= removalTarget then
                    log("Farm", "Target reached with Rare trees")
                    break
                end
            end
        end
    else
        log("Farm", "No Common/Uncommon/Rare trees found")
    end
    
    if #treesToRemove < removalTarget then
        log("Farm", "PHASE 2: Still need " .. (removalTarget - #treesToRemove) .. " more trees...")
        
        if hasBetterSeeds then
            log("Farm", "Have better seeds available for planting - can remove higher rarity trees")
            
            if hasDivineSeeds then
                log("Farm", "Using Divine seeds to replace lower rarity trees")
                
                if #treesToRemove < removalTarget and #epicTrees > 0 then
                    for i, tree in ipairs(epicTrees) do
                        table.insert(treesToRemove, {tree = tree, rarity = "Epic"})
                        if #treesToRemove >= removalTarget then break end
                    end
                end
                
                if #treesToRemove < removalTarget and #legendaryTrees > 0 then
                    for i, tree in ipairs(legendaryTrees) do
                        table.insert(treesToRemove, {tree = tree, rarity = "Legendary"})
                        if #treesToRemove >= removalTarget then break end
                    end
                end
                
                if #treesToRemove < removalTarget and #mythicalTrees > 0 then
                    for i, tree in ipairs(mythicalTrees) do
                        table.insert(treesToRemove, {tree = tree, rarity = "Mythical"})
                        if #treesToRemove >= removalTarget then break end
                    end
                end
            end
            
            if hasMythicalSeeds then
                log("Farm", "Using Mythical seeds to replace lower rarity trees")
                
                if #treesToRemove < removalTarget and #epicTrees > 0 then
                    for i, tree in ipairs(epicTrees) do
                        table.insert(treesToRemove, {tree = tree, rarity = "Epic"})
                        if #treesToRemove >= removalTarget then break end
                    end
                end
                
                if #treesToRemove < removalTarget and #legendaryTrees > 0 then
                    for i, tree in ipairs(legendaryTrees) do
                        table.insert(treesToRemove, {tree = tree, rarity = "Legendary"})
                        if #treesToRemove >= removalTarget then break end
                    end
                end
            end
            
            if hasLegendarySeeds then
                log("Farm", "Using Legendary seeds to replace Epic trees only")
                
                if #treesToRemove < removalTarget and #epicTrees > 0 then
                    for i, tree in ipairs(epicTrees) do
                        table.insert(treesToRemove, {tree = tree, rarity = "Epic"})
                        if #treesToRemove >= removalTarget then break end
                    end
                end
            end
        elseif totalTreeCount > CONFIG.MAX_TREES then
            log("Farm", "No better seeds but still need to remove trees to stay under limit")
            
            if #epicTrees > 0 then
                for i, tree in ipairs(epicTrees) do
                    table.insert(treesToRemove, {tree = tree, rarity = "Epic"})
                    if #treesToRemove >= removalTarget then break end
                end
            end
            
            if #treesToRemove < removalTarget and treesOverLimit > 10 and #legendaryTrees > 0 then
                log("Farm", "WARNING: Removing Legendary trees because we're far over the limit")
                for i, tree in ipairs(legendaryTrees) do
                    if i > 2 then break end -- Only remove up to 2 Legendary trees max
                    table.insert(treesToRemove, {tree = tree, rarity = "Legendary"})
                    if #treesToRemove >= removalTarget then break end
                end
            end
        end
    end
    
    if #treesToRemove == 0 then
        log("Farm", "No trees selected for removal")
        IS_REMOVING_TREES = false
        return
    end
    
    log("Farm", " Will remove " .. #treesToRemove .. " trees:")
    local removalCounts = {
        Common = 0,
        Uncommon = 0,
        Rare = 0, 
        Epic = 0,
        Legendary = 0,
        Mythical = 0,
        Divine = 0
    }
    
    for _, treeData in ipairs(treesToRemove) do
        removalCounts[treeData.rarity] = removalCounts[treeData.rarity] + 1
    end
    
    for rarity, count in pairs(removalCounts) do
        if count > 0 then
            log("Farm", "- " .. count .. " " .. rarity .. " trees")
        end
    end
    
    updateStatus('[Farm]: Removing ' .. #treesToRemove .. ' trees')
    
    local removedCount = 0
    
    local hasShovel = false
    for _, tool in next, character:GetChildren() do
        if tool:IsA("Tool") and string.find(tool.Name, "Shovel") then
            hasShovel = true
            break
        end
    end
    
    if not hasShovel then
        for _, tool in next, plr.Backpack:GetChildren() do
            if string.find(tool.Name, 'Shovel') then
                pcall(function() character.Humanoid:EquipTool(tool) end)
                task.wait(0.5)
                hasShovel = true
                break
            end
        end
    end
    
    if not hasShovel then
        log("Error", "No shovel found, cannot remove trees!", true)
        IS_REMOVING_TREES = false
        return
    end
    
    for i, treeData in ipairs(treesToRemove) do
        local tree = treeData.tree
        local rarity = treeData.rarity
        local timeout = tick()
        repeat wait(.1)
            if not tree or not tree.Parent or not tree.PrimaryPart then 
                log("Warning", "Tree no longer exists, skipping: " .. (tree and tree.Name or "Unknown"))
                return 
            end
            
            log("Farm", "Teleporting to " .. rarity .. " tree: " .. tree.Name .. " (" .. i .. "/" .. #treesToRemove .. ")")
            pcall(function()
                character.HumanoidRootPart.CFrame = tree.PrimaryPart.CFrame * CFrame.new(0, 0, 2)
            end)
                    
            local stillHasShovel = false
            for _, tool in next, character:GetChildren() do
                if tool:IsA("Tool") and string.find(tool.Name, "Shovel") then
                    stillHasShovel = true
                    break
                end
            end
            
            if not stillHasShovel then
                log("Farm", "Re-equipping shovel for tree #" .. i)
                for _, tool in next, plr.Backpack:GetChildren() do
                    if string.find(tool.Name, 'Shovel') then
                        pcall(function() character.Humanoid:EquipTool(tool) end)
                        task.wait(0.3)
                        break
                    end
                end
            end
            
            log("Farm", " REMOVING " .. rarity .. " tree: " .. tree.Name .. " (" .. i .. "/" .. #treesToRemove .. ")")
            removeItem:FireServer(tree.PrimaryPart)
            
            removedCount = removedCount + 1
            
            if i % 3 == 0 or i == #treesToRemove then
                log("Farm", "Progress: Removed " .. i .. "/" .. #treesToRemove .. " trees")
                updateStatus(string.format('[Farm]: Removed %d/%d trees', i, #treesToRemove))
            end
        until tick() - timeout > 5
        
        task.wait(2)
    end
    
    -- Update stats
    STATS.treesRemoved = STATS.treesRemoved + removedCount
    updateStats()
    
    -- Wait for server to process removals
    log("Farm", "Waiting for server to process all tree removals...")
    task.wait(3)
    
    -- Check results
    local remainingTrees = #Farm.Important.Plants_Physical:GetChildren()
    local treesRemoved = totalTreeCount - remainingTrees
    
    log("Farm", "Tree removal summary:")
    log("Farm", "- Starting tree count: " .. totalTreeCount)
    log("Farm", "- Trees targeted for removal: " .. #treesToRemove)
    log("Farm", "- Trees successfully removed: " .. treesRemoved)
    log("Farm", "- Current tree count: " .. remainingTrees .. "/" .. CONFIG.MAX_TREES)
    
    -- Save new tree state
    saveTreeState(remainingTrees)
    
    -- Update IS_REMOVING_TREES flag
    if remainingTrees <= CONFIG.MAX_TREES then
        log("Success", " Successfully reduced tree count below limit")
        IS_REMOVING_TREES = false
        
        -- If we removed trees to plant better ones, let the script know we want to plant right away
        if hasBetterSeeds and treesOverLimit <= 0 then
            log("Farm", "Now ready to plant higher rarity seeds!")
        end
    else
        log("Warning", " Still above tree limit (" .. remainingTrees .. "/" .. CONFIG.MAX_TREES .. "), will try again next cycle")
        IS_REMOVING_TREES = true
    end
    
    log("Farm", "============== TREE REMOVAL PROCESS COMPLETED ==============")
end

function collectAll()
    log("Farm", "Collecting ripe plants using remote")

    local plantsPhysical = Farm.Important.Plants_Physical:GetChildren()
    local totalRipe = 0
    local collected = 0
    local character = Utility.getCharacter()
    local backpackItems = plr.Backpack:GetChildren()

    if IS_MAX_TREES and tick() - delayCollectTrees > 60 * 2 then
        log("Farm", "Collecting trees - max trees not reached or delay expired")
        delayCollectTrees = tick()
        return
    end

    if #backpackItems >= CONFIG.MAX_SLOTS then
        log("Farm", "Backpack is full, cannot collect more plants")
        return
    end

    character.HumanoidRootPart.CFrame = CFrame.new(61.582096099853516, 2.999999761581421, 0.4267842769622803)

    for i, v in pairs(plantsPhysical) do
        for i1, v1 in next, v:GetChildren() do
            if v1.Name == "Fruits" then
                for i2, v2 in v1:GetChildren() do
                    remoteModule.Crops.Collect.send({
                        v2
                    })
                    collected += 1
                    totalRipe += 1
                    task.wait(0.05)
                    if collected >= CONFIG.MAX_SLOTS then
                        break
                    end
                end
            end
        end
    end

    if collected > 0 then
        log("Success", string.format("Collected %d/%d ripe plants using remote", collected, totalRipe))
        STATS.plantsCollected = STATS.plantsCollected + collected
        updateStats()
    else
        log("Farm", "No ripe plants found or collected")
    end

    log("Farm", "Remote collection cycle complete")
end

function sellAll()
    updateStatus('[Farm]: Selling items...')
    
    local character = Utility.getCharacter()
    local steven = NPCs:FindFirstChild('Steven')
    local maxRetries = 3
    local attempts = 0

    while not steven and attempts < maxRetries do
        attempts = attempts + 1
        warn('[Sell]: Steven not found, retrying (' .. attempts .. '/' .. maxRetries .. ')')
        Utility.safeTaskWait(1)
        steven = NPCs:FindFirstChild('Steven')
    end
    
    if not steven then
        log("Error", "Could not find Steven NPC after " .. maxRetries .. " attempts", true)
        return false
    end
    
    local distance = (character.HumanoidRootPart.Position - steven.HumanoidRootPart.Position).Magnitude
    if distance > 10 then
        repeat
            distance = (character.HumanoidRootPart.Position - steven.HumanoidRootPart.Position).Magnitude
            character.HumanoidRootPart.CFrame = NPCs:FindFirstChild('Steven').HumanoidRootPart.CFrame * CFrame.new(0, 0, 0)
            Utility.safeTaskWait(1)
        until distance <= 10
    end

    local attempt = 50
    while attempt > 0 do
        sellInventory:FireServer()
        attempt = attempt - 1
        task.wait(0.05)
    end
end

function sellPet()
    updateStatus('[Farm]: Selling Trash Pets...')
    local character = Utility.getCharacter()
    local petsPhysical = Farm.Important.Pets_Physical:GetChildren()
    local backpackItems = plr.Backpack:GetChildren()
    local playerData = getData()
    
end

function hatchEgg()
    local character = Utility.getCharacter()
    local objectsPhysical = Farm.Important.Objects_Physical:GetChildren()
    local backpackItems = plr.Backpack:GetChildren()
    local location = Farm.Important.Plant_Locations:FindFirstChild('Can_Plant')

    if not location then
        log("Error", "No valid planting location found", true)
        return
    end

    local eggCount = 0
    local eggsToHatch = {}
    
    for _, obj in pairs(objectsPhysical) do
        if obj.Name == 'PetEgg' then
            eggCount = eggCount + 1
            if obj:GetAttribute('TimeToHatch') and obj:GetAttribute('TimeToHatch') <= 0 then
                table.insert(eggsToHatch, obj)
            elseif obj:GetAttribute('TimeToHatch') then
                local timeLeft = math.floor(obj:GetAttribute('TimeToHatch'))
                log("Egg", "Egg not ready: " .. timeLeft .. "s remaining")
            end
        end
    end
    
    log("Egg", "Current egg count: " .. eggCount .. "/3 (Ready to hatch: " .. #eggsToHatch .. ")")
    
    if #eggsToHatch > 0 then
        for _, egg in ipairs(eggsToHatch) do
            updateStatus('[Egg]: Hatching Egg ...')
            log("Egg", "Hatching egg...")
            
            if egg:FindFirstChild("PetEgg") then
                character.HumanoidRootPart.CFrame = egg.PetEgg.CFrame
                task.wait(0.3)
                
                for attempt = 1, 5 do
                    petEggService:FireServer('HatchPet', egg)
                    task.wait(0.5)
                    
                    if not egg.Parent then
                        log("Success", "Successfully hatched pet egg!")
                        STATS.petsHatched = STATS.petsHatched + 1
                        updateStats()
                        break
                    end
                    
                    if attempt < 5 then
                        log("Egg", "Hatch attempt " .. attempt .. " failed, trying again")
                        task.wait(0.3)
                    else
                        log("Warning", "Failed to hatch egg after multiple attempts")
                    end
                end
            else
                log("Warning", "Egg model is missing PetEgg part")
            end
            
            break
        end
    elseif eggCount < 3 then
        local possiblePosition = Utility.canPlace(Farm, location, 50)
        if possiblePosition then
            for _, tool in next, backpackItems do
                local itemType = tool:GetAttribute('ItemType')
                if itemType == 'PetEgg' then
                    local eggName = tool:GetAttribute('ItemName') or "Unknown Egg"
                    updateStatus('[Egg]: Placing ' .. eggName)
                    log("Egg", "Attempting to place " .. eggName .. " at " .. tostring(possiblePosition))

                    pcall(function()
                        character.Humanoid:EquipTool(tool)
                    end)
                    task.wait(0.2)
                    
                    character.HumanoidRootPart.CFrame = CFrame.new(possiblePosition)
                    task.wait(0.3)
                    
                    local initialEggCount = eggCount
                    local placed = false
                    
                    for attempt = 1, 5 do
                        petEggService:FireServer('CreateEgg', possiblePosition)
                        task.wait(0.5)
                        
                        local newEggCount = 0
                        for _, obj in pairs(Farm.Important.Objects_Physical:GetChildren()) do
                            if obj.Name == 'PetEgg' then
                                newEggCount = newEggCount + 1
                            end
                        end
                        
                        if newEggCount > initialEggCount then
                            placed = true
                            log("Success", "Successfully placed egg on attempt " .. attempt)
                            break
                        end
                        
                        if attempt < 5 then
                            local randomOffset = Vector3.new(math.random(-2, 2), 0, math.random(-2, 2))
                            possiblePosition = possiblePosition + randomOffset
                            character.HumanoidRootPart.CFrame = CFrame.new(possiblePosition)
                            task.wait(0.2)
                        end
                    end
                    
                    if not placed then
                        log("Warning", "Failed to place egg after multiple attempts")
                    end
                    break
                end
            end
        else
            log("Egg", "No suitable position found for placing eggs")
        end
    end
end

function equipPets()
    local character = Utility.getCharacter()
    local playerData = getData()
    local equippedPets = playerData.PetsData.EquippedPets
    local currentPetsEquipped = #equippedPets
    local backpackItems = plr.Backpack:GetChildren()
    local location = Farm.Important.Plant_Locations:FindFirstChild('Can_Plant')
    local whitelistPets = {
        "Blood Kiwi"
    }
    
    if not location then
        log("Error", "No valid location found for equipping pets", true)
        return
    end

    -- Log status
    log("Pet", "Current equipped pets: " .. currentPetsEquipped .. "/3")
    
    -- Return if max pets already equipped
    if currentPetsEquipped >= 3 then
        return
    end
    
    -- Sort pets by rarity to equip best ones first
    local petsToEquip = {}
    
    for _, tool in next, backpackItems do
        local itemType = tool:GetAttribute('ItemType')
        local petUUID = tool:GetAttribute('PET_UUID')
        local petRarity = tool:GetAttribute('Rarity') or "Unknown"
        
        if itemType == 'Pet' and petUUID then
            table.insert(petsToEquip, {
                tool = tool,
                uuid = petUUID,
                rarity = petRarity,
                rarityValue = CONFIG.RARITY_ORDER[petRarity] or 0
            })
        end
    end
    
    -- Sort by rarity (highest first)
    table.sort(petsToEquip, function(a, b)
        return a.rarityValue > b.rarityValue
    end)
    
    -- Calculate how many more pets we can equip
    local spotsRemaining = 3 - currentPetsEquipped
    local equippedCount = 0
    
    -- Limit to available spots
    if #petsToEquip > spotsRemaining then
        petsToEquip = {unpack(petsToEquip, 1, spotsRemaining)}
    end
    
    -- Log found pets
    log("Pet", "Found " .. #petsToEquip .. " pets to equip")
    
    for i, petData in ipairs(petsToEquip) do
        local tool = petData.tool
        local petUUID = petData.uuid
        
        updateStatus(string.format('[Pet]: Equipping %s pet (%d/%d)', petData.rarity, i, #petsToEquip))
        log("Pet", "Equipping " .. petData.rarity .. " pet " .. i .. "/" .. #petsToEquip)
        
        -- Teleport to location
        local distance = (character.HumanoidRootPart.Position - location.Position).Magnitude
        if distance > 10 then
            character.HumanoidRootPart.CFrame = location.CFrame
            task.wait(0.5)
        end
        
        -- Equip the pet tool
        pcall(function()
            character.Humanoid:EquipTool(tool)
        end)
        task.wait(0.3)
        
        -- Try to equip with multiple attempts
        local equipped = false
        for attempt = 1, 5 do
            petsService:FireServer('EquipPet', petUUID, location.CFrame)
            task.wait(0.5)
            
            -- Check if successfully equipped
            local newData = getData()
            local newEquippedCount = #newData.PetsData.EquippedPets
            
            if newEquippedCount > currentPetsEquipped + equippedCount then
                equipped = true
                equippedCount = equippedCount + 1
                log("Success", "Successfully equipped pet on attempt " .. attempt)
                break
            end
            
            if attempt < 5 then
                log("Pet", "Equip attempt " .. attempt .. " failed, trying again")
                task.wait(0.3)
            else
                log("Warning", "Failed to equip pet after multiple attempts")
            end
        end
        
        -- Break if we're at max pets
        if currentPetsEquipped + equippedCount >= 3 then
            log("Pet", "Reached maximum of 3 equipped pets")
            break
        end
    end
    
    if equippedCount > 0 then
        log("Success", "Successfully equipped " .. equippedCount .. " pets")
    elseif #petsToEquip > 0 then
        log("Warning", "Failed to equip any pets despite having pets in inventory")
    end
end

function tradeMoonlit()
    warn('[Farm]: Trading Moonlit ...')
    local character = Utility.getCharacter()
    local backpackItems = plr.Backpack:GetChildren()
    local mydata = getData()
    local sheckles = mydata.Sheckles

    if sheckles <= 1000 then
        return
    end

    if mydata.NightQuestData.Experience and mydata.NightQuestData.Experience >= 530 then
        if sheckles >= 500000000 then
            local args = {
                [1] = "ResetQuestData"
            }

            game:GetService("ReplicatedStorage").GameEvents.NightQuestRemoteEvent:FireServer(unpack(args))
        end
        return
    end

    for _, tool in next, backpackItems do
        if string.find(tool.Name, 'Moonlit') then
            updateStatus('[Farm]: Trading Moonlit ...')
            local location = CONFIG.LOCATIONS.NIGHT_SHOP
            local distance = (character.HumanoidRootPart.Position - location.Position).Magnitude

            if distance > 10 then
                repeat
                    distance = (character.HumanoidRootPart.Position - location.Position).Magnitude
                    character.HumanoidRootPart.CFrame = location
                    Utility.safeTaskWait(1)
                until distance <= 10
            end

            nightQuestRemoteEvent:FireServer('SubmitAllPlants')
        end
    end
end

function getPathPets(name)
    local backpackItems = plr.Backpack:GetChildren()
    for i,v in pairs(backpackItems) do
        if string.find(v.Name, name) then
            return v
        end
    end
    return nil
end

function SellPets()
    local mydata = getData()
    local character = Utility.getCharacter()
    local PetsData = mydata.PetsData.PetInventory.Data
    local EquippedPets = mydata.PetsData.EquippedPets
    updateStatus('[Farm]: Selling pets...')
    for i,v in pairs(PetsData) do
        if not table.find(EquippedPets, i) then
            if ListPetData[v.PetType].Rarity ~= "Divine" then
                local heheBoi = getPathPets(v.PetType)
                local timeout = tick()
                repeat Utility.safeTaskWait(.5)
                    if not heheBoi then
                        log("Error", "Pet not found in backpack: " .. v.PetType, true)
                        break
                    end
                    if heheBoi then
                        log("Farm", "Selling pet: " .. heheBoi.Name)
                        local args = {
                            [1] = heheBoi
                        }

                        game:GetService("ReplicatedStorage").GameEvents.SellPet_RE:FireServer(unpack(args))
                    end
                until not heheBoi or heheBoi.Parent == nil or timeout - tick() > 2
            end
        end
    end
end

function ultraBoost()
    task.spawn(function()
        pcall(function()
            settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
            UserSettings().GameSettings.MasterVolume = 0
            UserSettings().GameSettings.SavedQualityLevel = Enum.SavedQualitySetting.QualityLevel1
        end)

        -- Setup Virtualize if missing
        if _G.lag then return end
        _G.lag = true

        -- Setup Virtualize if missing
        if not LPH_OBFUSCATED then
            LPH_NO_VIRTUALIZE = function(...) return ... end
            LPH_JIT_MAX = function(...) return ... end
        end

        -- Services and Players
        local RunService = game:GetService("RunService")
        local Player = game.Players.LocalPlayer
        local workspace = game.Workspace
        local Lighting = game.Lighting
        local ReplicatedStorage = game.ReplicatedStorage
        local ReplicatedFirst = game.ReplicatedFirst
        local PlayerScripts = Player:WaitForChild("PlayerScripts")
        local Character = Player.Character or Player.CharacterAdded:Wait()
        local Backpack = Player:WaitForChild("Backpack")
        local PlayerGui = Player:WaitForChild("PlayerGui")

        -- Config
        local whiteScreen = _G.whiteScreen or false
        local mode = _G.Mode or true
        local fps = _G.fps or 5

        -- Target folders
        local to_check = {
            workspace,
            Lighting,
            ReplicatedStorage,
            ReplicatedFirst,
            PlayerScripts,
            Character,
            Backpack,
        }

        -- State cache
        local isProcessing = false
        local index = 1
        local cache = {}

        -- Function to disable visual and audio effects
        local function check(v)
            if not v then return end
            if string.find(v.Name, 'Effect') then
                if v:IsA('Instance') and v:IsA('GuiObject') then
                    v.Visible = false
                elseif v.Enabled ~= nil then
                    v.Enabled = false
                end
            end
            if v:IsA('BasePart') or v:IsA('Decal') or v:IsA('Texture') then
                v.Transparency = 1
            elseif v:IsA('Sound') then
                v:Destroy()
            elseif v:IsA('ParticleEmitter') or v:IsA('ScreenGui') or v:IsA('Frame') or v:IsA('Clouds') or v:IsA('Beam') then
                v.Enabled = false
            end
        end

        -- Start processing
        function startProcessing()
            if isProcessing then return end
            isProcessing = true
            index = 1
        end

        -- Process one folder per Heartbeat
        function processDescendants()
            if index > #to_check then
                isProcessing = false
                return
            end

            local v = to_check[index]
            if v and not cache[v.Name] then
                cache[v.Name] = v.DescendantAdded:Connect(function(obj)
                    pcall(check, obj)
                end)
            end

            if v then
                for _, obj in ipairs(v:GetDescendants()) do
                    pcall(check, obj)
                end
            end

            index = index + 1
        end

        -- GPU saving
        function SaveGpu()
            if whiteScreen then RunService:Set3dRenderingEnabled(false) end
            if setfpscap then setfpscap(fps) end
        end

        function UnSaveGpu()
            if not whiteScreen then
                RunService:Set3dRenderingEnabled(true)
            end
            if setfpscap then setfpscap(30) end
        end

        function CheckMode()
            local currentMode = _G.Mode or true
            local currentWhiteScreen = _G.whiteScreen or true
            local currentFps = _G.fps or 5
            if currentMode ~= lastMode or currentWhiteScreen ~= whiteScreen or currentFps ~= fps then
                whiteScreen = currentWhiteScreen
                fps = currentFps
                mode = currentMode

                if mode then
                    SaveGpu()
                else
                    UnSaveGpu()
                end
                lastMode = currentMode
            end
        end

        -- Run
        startProcessing()

        RunService.Heartbeat:Connect(function()
            if isProcessing then
                processDescendants()
            end
            CheckMode()
        end)

        pcall(function()
            if Farm and Farm.Important.Plants_Physical then
                local plantsPhysical = Farm.Important.Plants_Physical
                for _, v in next, plantsPhysical:GetDescendants() do
                    pcall(function()
                        v.Transparency = 1
                    end)
                end
                plantsPhysical.DescendantAdded:Connect(function(obj)
                    pcall(function()
                        obj.Transparency = 1
                    end)
                end)
            end
        end)

        for _, v in next, plr.PlayerScripts:GetDescendants() do
            pcall(function()
                v.Disabled = true
            end)
        end

        task.spawn(function()
            while task.wait(0.1) do
                local currentCamera = workspace.CurrentCamera
                currentCamera.CameraType = Enum.CameraType.Scriptable
                currentCamera.CFrame = CFrame.new(1000, 1000, 1000)
            end
        end)
    end)
end

-- Anti AFK
plr.Idled:Connect(function()
    virtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    task.wait(0.25)
    virtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
end)

for i,v in pairs(getgenv().code) do
    local args = {
        [1] = "ClaimCode",
        [2] = v
    }

    game:GetService("ReplicatedStorage").GameEvents.ClaimableCodeService:FireServer(unpack(args))
end

Player.Backpack.ChildAdded:Connect(function(obj)
    if string.find(obj.Name, 'Raccoon') or string.find(obj.Name, 'Dragonfly') or string.find(obj.Name, 'Owl') or string.find(obj.Name, 'Kiwi') then
        local payload = {
            content = "@everyone",
            embeds = {
                {
                    title       = " New Pet Notification",
                    description = "Here are the details:",
                    fields = {
                        { name = "Pet",     value = obj.Name,     inline = true },
                        { name = "Account", value = Player.Name,  inline = true },
                    },
                    timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
                    color     = 0x00FF00,
                }
            }
        }
        request({
            Url = getgenv().webhook,
            Method = 'POST',
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = game:GetService("HttpService"):JSONEncode(payload)
        })
    end
end)

-- Main loop
function mainLoop()
    local initSuccess, initError = pcall(function()
        waitDataLoadedAndGetFarm()
        setupCharacter()
        createStatus()
        ultraBoost()
        
        local savedState = loadTreeState()
        if savedState and savedState.needsRemoval then
            log("System", "Previous session indicated trees need removal - scheduling immediate check")
            IS_REMOVING_TREES = true
            
            -- Force immediate tree removal check
            task.spawn(function()
                task.wait(5) -- Wait for game to fully load
                local treeCount = #Farm.Important.Plants_Physical:GetChildren()
                log("System", "Current tree count after loading: " .. treeCount .. "/" .. CONFIG.MAX_TREES)
                
                if (treeCount > CONFIG.MAX_TREES) then
                    log("System", "Confirmed trees need removal - starting removal process")
                    pcall(destroyTrees)
                else
                    log("System", "Tree count is now under limit - no removal needed")
                    IS_REMOVING_TREES = false
                    saveTreeState(treeCount)
                end
            end)
        end
    end)
    
    if not initSuccess then
        warn("Critical initialization error: " .. tostring(initError))
        
        if not UI.mainFrame then
            local errorGui = Instance.new("ScreenGui")
            errorGui.Name = "ErrorGui"
            errorGui.Parent = coreGui
            
            local errorFrame = Instance.new("Frame")
            errorFrame.Size = UDim2.new(0, 300, 0, 100)
            errorFrame.Position = UDim2.new(0.5, -150, 0.5, -50)
            errorFrame.BackgroundColor3 = Color3.fromRGB(220, 75, 75)
            errorFrame.BorderSizePixel = 0
            errorFrame.Parent = errorGui
            
            local errorText = Instance.new("TextLabel")
            errorText.Size = UDim2.new(1, -20, 1, -20)
            errorText.Position = UDim2.new(0, 10, 0, 10)
            errorText.BackgroundTransparency = 1
            errorText.Font = Enum.Font.GothamBold
            errorText.TextSize = 14
            errorText.TextColor3 = Color3.fromRGB(255, 255, 255)
            errorText.TextWrapped = true
            errorText.Text = "Error initializing farm: " .. tostring(initError)
            errorText.Parent = errorFrame
            
            return
        end
    end
    
    task.spawn(function()
        while task.wait(1) do
            local treeCount = #Farm.Important.Plants_Physical:GetChildren()
            if tick() % 60 < 1 then
                saveTreeState(treeCount)
            end
            
            -- Add a tree count check at start of each cycle
            log("Debug", "Current tree count at cycle start: " .. treeCount .. "/" .. CONFIG.MAX_TREES)
            
            if treeCount > CONFIG.MAX_TREES then
                log("Warning", "Tree count exceeds maximum, prioritizing tree removal")
                -- Force tree removal if needed
                local treesRemoved = false
                for attempt = 1, 3 do
                    log("Farm", "Tree removal attempt #" .. attempt)
                    local success, err = pcall(destroyTrees)
                    if success then
                        treesRemoved = true
                        break
                    else
                        log("Error", "Failed in destroyTrees attempt #" .. attempt .. ": " .. tostring(err), true)
                        Utility.safeTaskWait(1)
                    end
                end
                
                if not treesRemoved then
                    log("Error", "All tree removal attempts failed, continuing with regular cycle", true)
                else
                    -- Skip other tasks this cycle if we successfully removed trees
                    log("Farm", "Trees removed, continuing to next cycle")
                end
            end
            
            -- Regular cycle continues below
            local success, err = pcall(destroyTrees)
            if not success then
                log("Error", "Failed in destroyTrees: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
            
            local success, err = pcall(collectAll)
            if not success then
                log("Error", "Failed in collectAll: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
            
            local success, err = pcall(tradeMoonlit)
            if not success then
                log("Error", "Failed in tradeMoonlit: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
            
            local success, err = pcall(sellAll)
            if not success then
                log("Error", "Failed in sellAll: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
            
            local success, err = pcall(buySeeds)
            if not success then
                log("Error", "Failed in buySeeds: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
            
            local success, err = pcall(plantSeeds)
            if not success then
                log("Error", "Failed in plantSeeds: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)

            local success, err = pcall(buyMoon)
            if not success then
                log("Error", "Failed in buyMoon: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)

            local success, err = pcall(buyEggs)
            if not success then
                log("Error", "Failed in buyEggs: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
            
            local success, err = pcall(hatchEgg)
            if not success then
                log("Error", "Failed in hatchEgg: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
            
            local success, err = pcall(equipPets)
            if not success then
                log("Error", "Failed in equipPets: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
            local success, err = pcall(SellPets)
            if not success then
                log("Error", "Failed in SellPets: " .. tostring(err), true)
            end
            Utility.safeTaskWait(0.5)
        end
    end)
    getgenv().isloaded = true
    log("System", "Farm automation started successfully")
end

-- Start the farm
mainLoop()
